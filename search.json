[{"title":"Subgraph Matching","url":"/2023/10/26/Subgraph-Matching/","content":"子图匹配问题子图同构(subgraph isomorphism)，又名子图匹配(subgraph matching)，直观感受如图：\n\n\n\n普通的算法不太能work，需要学习新东西。\n子图匹配算法对于子图同构（匹配），采用NetworkX库文档中的定义：\nGraph theory literature can be ambiguous about the meaning of the above statement, and we seek to clarify it now.\nIn the VF2 literature, a mapping M is said to be a graph-subgraph isomorphism iff M is an isomorphism between G2 and a subgraph of G1. Thus, to say that G1 and G2 are graph-subgraph isomorphic is to say that a subgraph of G1 is isomorphic to G2.\nOther literature uses the phrase ‘subgraph isomorphic’ as in ‘G1 does not have a subgraph isomorphic to G2’. Another use is as an in adverb for isomorphic. Thus, to say that G1 and G2 are subgraph isomorphic is to say that a subgraph of G1 is isomorphic to G2.\nFinally, the term ‘subgraph’ can have multiple meanings. In this context, ‘subgraph’ always means a ‘node-induced subgraph’. Edge-induced subgraph isomorphisms are not directly supported, but one should be able to perform the check by making use of nx.line_graph(). For subgraphs which are not induced, the term ‘monomorphism’ is preferred over ‘isomorphism’.\nLet G&#x3D;(N,E) be a graph with a set of nodes N and set of edges E.\n\nif G’&#x3D;(N’,E’) is a subgraph, then:N’ is a subset of N E’ is a subset of E\n\nIf G’&#x3D;(N’,E’) is a node-induced subgraph, then:N’ is a subset of N E’ is the subset of edges in E relating nodes in N’\n\nIf G’&#x3D;(N’,E’) is an edge-induced subgraph, then:N’ is the subset of nodes in N related by edges in E’ E’ is a subset of E\n\nIf G’&#x3D;(N’,E’) is a monomorphism, then:N’ is a subset of N E’ is a subset of the set of edges in E relating nodes in N’\n\n\nNote that if G’ is a node-induced subgraph of G, then it is always a subgraph monomorphism of G, but the opposite is not always true, as a monomorphism can have fewer edges.\n翻译为：\n在图论文献中，上述陈述的含义可能会有歧义，我们现在寻求澄清它。\n在VF2文献中，一个映射M被称为图-子图同构，当且仅当M是G2和G1的一个子图之间的同构。因此，说G1和G2是图-子图同构意味着G1的一个子图同构于G2。\n其他文献使用短语”子图同构”，例如”G1没有一个子图同构于G2”。另一种用法是作为同构的副词。因此，说G1和G2是子图同构意味着G1的一个子图同构于G2。\n最后，术语”子图”可能具有多重含义。在这个上下文中，”子图”总是指”节点诱导子图”。不直接支持”边诱导子图同构”，但可以通过使用nx.line_graph()来执行检查。对于不是诱导的子图，更喜欢术语”单射”而不是”同构”。\n让G&#x3D;(N,E)表示一个具有节点集N和边集E的图。\n让 G&#x3D;(N,E) 表示一个具有节点集 N 和边集 E 的图。\n\n如果 G’&#x3D;(N’,E’) 是一个子图，那么：N’ 是 N 的子集E’ 是 E 的子集\n\n如果 G’&#x3D;(N’,E’) 是一个节点诱导子图，那么：N’ 是 N 的子集E’ 是 E 中与节点 N’ 中的节点相关的边的子集\n\n如果 G’&#x3D;(N’,E’) 是一个边诱导子图，那么：N’ 是与边 E’ 中涉及的节点相关的节点的子集E’ 是 E 的子集\n\n如果 G’&#x3D;(N’,E’) 是一个单射（monomorphism），那么：N’ 是 N 的子集E’ 是与节点 N’ 中的节点相关的边的子集\n\n\n需要注意的是，如果 G’ 是 G 的一个节点诱导子图，那么它总是 G 的一个子图单射，但反之则不一定成立，因为一个单射可以具有较少的边。\n穷举法这是一种直观但不够高效的方法。穷举法的思想是遍历主图中的所有可能的子图，然后检查每个子图是否同构于给定的子图。这是一个从0开始学习子图匹配问题的好方法，因为它不需要复杂的数据结构或算法知识，但它在大规模图上的性能较差。\n下面是穷举法的基本步骤：\n\n生成子图候选：遍历主图中的所有节点，生成所有可能的子图候选。这可以通过递归或迭代的方式完成。\n\n检查同构：对于每个生成的子图候选，检查它是否同构于给定的子图。这可以通过遍历给定子图的节点和边，然后尝试在生成的子图中找到相应的节点和边来实现。\n\n记录匹配：如果找到同构，记录匹配的子图。\n\n重复步骤1和2：继续生成更多的子图候选，并重复步骤2，直到遍历完整个主图。\n\n返回匹配结果：返回找到的所有同构子图。\n\n\n虽然穷举法是一种简单直观的方法，但在大型图上的性能非常低，因为它需要生成和检查大量的子图候选，特别是对于大型、高度连接的图。因此，实际应用中更常使用高效的子图匹配算法，如VF2算法、格拉斯哥求解器等。\n但如果是想从0开始学习子图匹配问题，穷举法是一个不错的起点，可以帮助你理解问题的本质和挑战。\n穷举法示例代码简单的穷举法可以直接用GPT生成，针对具有点属性，边属性的有向图的示例代码如下：\nimport networkx as nxfrom itertools import combinationsdef is_subgraph_isomorphic(G, H):    subgraph_matches = []    for nodes in combinations(G.nodes, len(H.nodes)):        subgraph = G.subgraph(nodes)        if is_isomorphic_with_attributes(subgraph, H):            subgraph_matches.append(subgraph)    return subgraph_matchesdef is_isomorphic_with_attributes(G, H):    if not set(G.nodes) == set(H.nodes) or not set(G.edges) == set(H.edges):        return False    for node in G.nodes:        if G.nodes[node] != H.nodes[node]:            return False    for edge in G.edges:        if G.edges[edge] != H.edges[edge]:            return False    return True# 创建主图G（有向图）G = nx.DiGraph()G.add_edge(&#x27;A&#x27;, &#x27;B&#x27;, weight=1)G.add_edge(&#x27;B&#x27;, &#x27;C&#x27;, weight=2)G.add_edge(&#x27;C&#x27;, &#x27;D&#x27;, weight=3)G.nodes[&#x27;A&#x27;][&#x27;label&#x27;] = &#x27;A&#x27;G.nodes[&#x27;B&#x27;][&#x27;label&#x27;] = &#x27;B&#x27;G.nodes[&#x27;C&#x27;][&#x27;label&#x27;] = &#x27;C&#x27;G.nodes[&#x27;D&#x27;][&#x27;label&#x27;] = &#x27;D&#x27;# 创建子图H（有向图）H = nx.DiGraph()H.add_edge(&#x27;A&#x27;, &#x27;B&#x27;, weight=1)H.add_edge(&#x27;B&#x27;, &#x27;C&#x27;, weight=2)H.nodes[&#x27;A&#x27;][&#x27;label&#x27;] = &#x27;A&#x27;H.nodes[&#x27;B&#x27;][&#x27;label&#x27;] = &#x27;B&#x27;H.nodes[&#x27;C&#x27;][&#x27;label&#x27;] = &#x27;C&#x27;# 查找与子图H同构的所有子图subgraph_matches = is_subgraph_isomorphic(G, H)# 打印匹配结果for subgraph in subgraph_matches:    print(&quot;Matched Subgraph:&quot;)    print(&quot;Nodes:&quot;, subgraph.nodes)    print(&quot;Edges:&quot;, subgraph.edges)\n\nVF2算法VF2算法（Vocabulary-Based Fast Subgraph Isomorphism）是一种用于子图同构检测的经典算法。它使用了节点标签和边连接关系来进行匹配，允许在主图中查找与子图同构的子图。\nVF2算法的主要思想如下：\n\n初始化\n  从主图和子图的起始节点开始，尝试将它们匹配。如果节点标签匹配，将其标记为匹配，并递归地尝试匹配它们的邻居。\n\n扩展\n  如果已经有部分匹配，尝试为主图中的未匹配节点找到匹配的子图节点，以扩展匹配。扩展时要满足节点标签匹配和边的连接关系一致的条件。\n\n回溯\n  如果不能找到合适的扩展，算法将回溯到前一个状态，取消当前的匹配，然后尝试其他可能的匹配。\n\n终止条件\n  当所有的节点都匹配或者找不到进一步的匹配时，算法结束。\n\n多重匹配\n  VF2算法可以找到多个匹配，而不仅仅是一个。\n\n\n使用VF2算法进行子图同构匹配示例import networkx as nx# 使用DiGraphMatcher进行子图匹配，考虑节点属性和边属性matcher = nx.isomorphism.DiGraphMatcher(G, H,    node_match=lambda x, y: x[&#x27;label&#x27;] == y[&#x27;label&#x27;],    edge_match=lambda x, y: x[&#x27;weight&#x27;] == y[&#x27;weight&#x27;])# 获取子图匹配的映射结果mapping = matcher.mappingprint(mapping)\n\nVF2算法流程伪代码\nVF2是递归函数，它尝试为主图G中的节点找到匹配的子图H中的节点。如果找到合法匹配，将其添加到映射(mapping)中，并递归继续查找下一个匹配。当映射(mapping)覆盖了子图H中的所有节点时，报告找到的同构。\n\nis_feasible 函数用于检查当前尝试的匹配是否合法。它考虑了节点标签的匹配，以及边连接关系的匹配。\n\n\nVF2(G, H, mapping):    if mapping covers all nodes in H:        # Found a valid isomorphism        report(mapping)    u = choose an unmatched node in G    for v in H such that is_feasible(u, v, mapping):        mapping.add(u, v)        VF2(G, H, mapping)        mapping.remove(u, v)is_feasible(u, v, mapping):    if not label_match(G.nodes[u], H.nodes[v]):        return False    for u_i in G.neighbors(u):        if mapping[u_i] is not None:            v_i = mapping[u_i]            if not label_match(G.nodes[u], H.nodes[v]):                return False            if not edge_match(G.edges(u, u_i), H.edges(v, v_i)):                return False    return True\n格拉斯哥求解器格拉斯哥求解器（Glasgow Subgraph Solver）的算法基于子图匹配和子图同构问题的研究，它采用了一种称为“模式化规约”（Pattern Refinement）的技术。\n图数据库和模式定义：用户首先提供一个图数据库，其中包含多个图，以及一个或多个图形模式（子图），这些模式将用于搜索和匹配。每个图和模式都由节点和边组成，可以具有不同的属性或标签。\n模式化规约：格拉斯哥求解器使用模式化规约技术来减少搜索空间和提高效率。\n基本思想如下：\n\n选择一个模式（子图）以作为初始模式。\n\n将该初始模式与图数据库中的每个图进行匹配。\n\n如果找到匹配，将该模式与匹配的图形合并，得到一个新的模式。\n\n使用新模式重复匹配过程。\n\n继续迭代，逐渐构建更大的模式。\n\n这个过程会生成一系列模式，这些模式被称为“模式族”。模式族是一组与图数据库中的数据集相关的子图。这些模式族通常会更小，并且包含了一些通用的特征，以减少匹配过程的复杂性。\n\n子图匹配：一旦生成了模式族，格拉斯哥求解器使用这些模式来进行子图匹配。具体的匹配算法可能基于图的同构性，但由于使用了模式化规约技术，它通常更高效。\n\n匹配结果报告：匹配过程会返回匹配的结果，即在图数据库中找到的满足模式的子图。\n\n\n格拉斯哥求解器的关键特点包括使用模式化规约技术来减少搜索空间，以及支持图数据库中的模式匹配。这种方法可以用于数据挖掘、图形搜索和其他应用中，特别是在需要处理大规模图数据库时。\n算法庞大复杂 ，不过我找到了代码：Glasgow Subgraph Solver可以使用，使用方法在后文中会提及。\n我可以成功运行的代码针对具有点属性，边属性的有向图的穷举法（Python）\n使用NX库内置的VF2算法（Python）\n一个开源的格拉斯哥求解器（C++）\n参考一篇介绍子图匹配的英文博客\n一篇介绍ULLMANN算法的日文博客\n论文：Glasgow Subgraph Solver\n代码：Glasgow Subgraph Solver\nNX库文档\n图匹配算法 from Bilibili\n"},{"title":"My First Blog","url":"/2023/10/26/hello-world/","content":"Java, C++, Algo, Positioning and navigation algorithm\n\n\n\n\n““hexo new “text”hexo g -dhexo clean &amp;&amp; hexo g -d\n"}]